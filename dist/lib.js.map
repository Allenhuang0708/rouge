{"version":3,"sources":["rouge.js"],"names":[],"mappings":"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","file":"lib.js","sourcesContent":["/*\n * @Author: Lim Mingjie, Kenneth\n * @Date:   2014-12-21 01:48:14\n * @Last Modified by:   Astrianna\n * @Last Modified time: 2015-01-14 17:08:02\n *\n * @flow\n */\n\n'use strict';\n\n(function(window) {\n    var rouge = (function() {\n        // Specify lodash as a dependency if running in a Node environment\n        if (typeof(module) === 'object' && module && typeof(module.exports) === 'object') {\n            var _ = require('lodash-node');\n        }\n\n        /**\n         * Returns the factorial of a number. For speed, this uses a memoized\n         * recursive function with a fixed point at n = 0.\n         * @param  Number n The number for which the factorial should be calculated\n         * @return Number   The factorial of n\n         */\n        var fact = _.memoize(function(n) {\n            return n === 0 ? 1 : n * fact(n - 1);\n        });\n\n        /**\n         * Returns the length of the longest common subsequence of a pair of strings.\n         * Depending on how one wishes to use this, the inputs may be character arrays\n         * (corresponding to the LCS for words) or word arrays (corresponding to the\n         * LCS for sentences). For speed, this uses a dynamic programming approach\n         * with search-space pruning for an average case of O(mn).\n         * @param  Array candidate An array of strings to be compared.\n         *                         This array must be sensitive to ordering.\n         * @param  Array reference An array of strings to be compared.\n         *                         This array must be sensitive to ordering.\n         * @return Number          The length of the longest common subsequence\n         *                         between the candidate and reference strings.\n         */\n        var lcs = function(candidate, reference) {\n            // Normalize both inputs by converting them to lowercase. Failing\n            // to do so means comparing 'A' and 'a' is falsey. Modify as appropriate.\n            var candidate = _.invoke(candidate, String.prototype.toLowerCase),\n                reference = _.invoke(reference, String.prototype.toLowerCase);\n\n            // Initialize pointers for moving through the search space\n            var startIdx = 0,\n                candidateEndIdx = candidate.length - 1,\n                referenceEndIdx = reference.length - 1,\n                similarityCount = 0;\n\n            // If the first two entries are identical, ignore them in the final\n            // comparison, but bump the count\n            while (candidate[startIdx] === reference[startIdx]) {\n                startIdx++;\n\n                similarityCount++;\n            }\n\n            // If the last two entries are identical, ignore them in the final\n            // comparison, but bump the count\n            while (candidate[candidateEndIdx] === reference[referenceEndIdx]) {\n                candidateEndIdx--;\n                referenceEndIdx--;\n\n                similarityCount++;\n            }\n\n            // Slice the original arrays with the new indices\n            var trimmedCandidate = candidate.slice(startIdx, candidateEndIdx + 1),\n                trimmedReference = reference.slice(startIdx, referenceEndIdx + 1);\n\n            // Preallocate an update table\n            var cTable = [];\n\n            // Zero-fill the table. The number of columns corresponds to the length\n            // of the reference input, and the number of rows corresponds to\n            // the length of the candidate input.\n            for (var i = 0; i <= trimmedReference.length; i++) {\n                cTable.push(Uint8Array(trimmedCandidate.length + 1));\n            }\n\n            // Perform the Bellman-Ford Update by looping through the update table.\n            // If entries match, increment the current value in the table. Otherwise,\n            // propagate the previous value. Note that this table is triangular.\n            for (var i = 1; i <= trimmedReference.length; i++) {\n                for (var j = 1; j <= trimmedCandidate.length; j++) {\n                    if (trimmedReference[i - 1] === trimmedCandidate[j - 1]) {\n                        cTable[i][j] = cTable[i - 1][j - 1] + 1;\n                    } else {\n                        cTable[i][j] = Math.max(cTable[i][j - 1], cTable[i - 1][j]);\n                    }\n                }\n            }\n\n            // The last value in the update table is the length of the LCS for the\n            // reduced search space. Add that to the original number of matches\n            // to get the final result\n            return cTable[trimmedReference.length][trimmedCandidate.length] + similarityCount;\n        }\n\n        /**\n         * Returns the skip bigrams for an input.\n         * @param  Array wordArr An array of strings\n         * @return Array         An array of skip bigrams\n         */\n        var skipBigram = function(wordArr) {\n            // Sanity check: If there's less than two words, no way we're\n            // going to produce a skip bigram\n            if (wordArr.length < 2) {\n                return null;\n            } else {\n                // Loop through every word\n                return wordArr.reduce(function(acc, currWord, index, wordBank) {\n                    // Take every word after the first one and pair them up\n                    for (var i = index + 1; i < wordBank.length; i++) {\n                        acc.push(currWord + wordBank[i]);\n                    }\n\n                    return acc;\n                }, []);\n            }\n        }\n\n        /**\n         * Returns the n-grams for an input, for the provided n.\n         * @param  Array wordArr An array of strings\n         * @param  Number n      The size of the gram to be returned\n         * @return Array         An array of n-grams\n         */\n        var extractGram = function(wordArr, n) {\n            // Sanity checks. This one's kind of obvious\n            if (n === 0 || n > wordArr.length) {\n                return null;\n            } else if (n === 1) {\n                // Short circuit if unigrams are requested\n                return wordArr;\n            } else {\n                // Loop through every word\n                return wordArr.reduce(function(acc, _, index, wordBank) {\n                    // So long there's still room for the sliding window to fit,\n                    // we can create a gram\n                    if (index + n <= wordBank.length) {\n                        var currGram = '';\n\n                        // Straightforward string concatenation\n                        for (var i = index; i < index + n; i++) {\n                            currGram += wordBank[i].toString();\n                        }\n\n                        return acc.concat([currGram]);\n                    } else {\n                        return acc;\n                    }\n                }, []);\n            }\n        }\n\n        /**\n         * Evaluates a candidate against a set of references using the specified\n         * method by averaging over n-1 comparisons in a leave-one-out approach.\n         * This is the standard statistical jackknifing method for approximating\n         * human responses.\n         * @param  Array candidate      An array of strings to be compared\n         * @param  Array references     An array of string arrays to be compared.\n         * @param  Function evalMethod  A lambda or function handle which accepts\n         *                              two inputs and returns a numerical output\n         * @return Number               The average of the argmax for each set of results\n         */\n        var evalJackKnife = function(candidate, references, evalMethod) {\n            // Preallocate an array to hold the results of performing\n            // pairwise comparisons\n            var pairwiseResults = [];\n\n            for (var i = 0; i < references.length; i++) {\n                // Go through each reference in order\n                var result = references.reduce(function(acc, currRef, index) {\n                    // Exclude the current reference as we go through, effectively\n                    // performing a leave-one-out comparison\n                    if (index !== i) {\n                        acc.push(evalMethod(candidate, currRef));\n                    }\n\n                    return acc;\n                }, []);\n\n                // Only consider the argmax for the current set of results\n                pairwiseResults.push(_.max(result));\n            }\n\n            // Average all the pairwise results\n            var sumResult = pairwiseResults.reduce(function(acc, currResult) {\n                return acc + currResult;\n            }, 0);\n\n            return sumResult / pairwiseResults.length;\n        }\n\n        /**\n         * Returns the ROUGE-N metric for a candidate and a set of references.\n         * @param  Array candidate      An array of strings to be compared\n         * @param  Array reference      An array of string arrays to be compared\n         * @param  Number n             The number of grams to use\n         * @param  Boolean jackKnife    Flag for whether jackknifing should be used\n         * @return Number               The calculated ROUGE-N value\n         */\n        var evalNGram = function(candidate, reference, n=1, jackKnife=false) {\n            // Specify some sane defaults. The original paper suggests that unigrams\n            // give good approximation of human behavior, and statistics is a nice thing.\n            // var n = n || 1,\n            //     jackKnife = jackKnife !== false;\n\n            // Tokenize the candidate input and extract grams\n            var candidateWords = candidate.match(/\\w+/g),\n                candidateGrams = extractGram(candidateWords, n);\n\n            // Case where only one reference is provided\n            if (typeof(reference) === 'string' || (_.isArray(reference) && reference.length === 1)) {\n                // Tokenize the reference\n                if (typeof(reference) === 'string') {\n                    var referenceWords = reference.match(/\\w+/g);\n                } else {\n                    var referenceWords = reference[0].match(/\\w+/g);\n                }\n\n                // Extract grams from the tokenized reference\n                var referenceGrams = extractGram(referenceWords, n),\n                    referenceGramCount = referenceGrams.length;\n\n                // Find the number of matching grams by taking the intersection\n                // of the two arrays\n                var matchedGrams = _.intersection(candidateGrams, referenceGrams),\n                    matchedGramCount = matchedGrams.length;\n\n                return matchedGramCount / referenceGramCount;\n            // Case where multiple references are provided\n            } else if (_.isArray(reference) && reference.length > 1) {\n                if (jackKnife) {\n                    // Here we pass in an anonymous function that wraps the\n                    // current function (a la mode recursive), except we turn off\n                    // jackknifing because it does not matter - only one reference\n                    return evalJackKnife(candidate, reference, function(x, y) {\n                        return evalNGram(x, y, n, false);\n                    });\n                } else {\n                    // Extract grams from each of the references, but maintain\n                    // the overall hierarchy (i.e. we're not concatenating all\n                    // the grams into one giant array)\n                    var referenceGramCount = 0,\n                        referenceGrams = reference.reduce(function(acc, currRef) {\n                            var words = currRef.match(/\\w+/g),\n                                grams = extractGram(words, n);\n\n                            referenceGramCount += grams.length;\n\n                            return acc.concat([grams]);\n                        }, []);\n\n                    var matchCount = 0;\n\n                    // Go through each set of reference grams and sum the results\n                    referenceGrams.forEach(function(ref) {\n                        var matchedGrams = _.intersection(candidateGrams, ref);\n\n                        matchCount += matchedGrams.length;\n                    });\n\n                    return matchCount / referenceGramCount;\n                }\n            } else {\n                return null;\n            }\n        }\n\n        /**\n         * Returns the ROUGE-L metric for a candidate and a set of references\n         * @param  Array candidate      An array of strings to be compared\n         * @param  Array reference      An array of string arrays to be compared\n         * @param  Boolean jackKnife    Flag for whether jackknifing should be used\n         * @return Number               The calculated ROUGE-L value\n         */\n        var evalLCS = function(candidate, reference) {\n            // Tokenize the candidate input to sentences\n            var candidateSentences = candidate.split(/[\\.!\\?]\\s/),\n                candidateWordCount = candidate.match(/\\w+/g).length;\n\n            // Case where only one reference is provided\n            if (typeof(reference) === 'string' || (_.isArray(reference) && reference.length === 1)) {\n                // Tokenize the ference\n                if (typeof(reference) === 'string') {\n                    var referenceSentences = reference.split(/[\\.!\\?]\\s/),\n                        referenceWordCount = reference.match(/\\w+/g).length;\n                } else {\n                    var referenceSentences = reference[0].split(/[\\.!\\?]\\s/),\n                        referenceWordCount = reference[0].match(/\\w+/g).length;\n                }\n\n                var lcsSum = referenceSentences.reduce(function(acc, reference) {\n                    // Find the LCS length for each sentence pair\n                    var lcsArr = candidateSentences.map(function(candidate) {\n                        return lcs(candidate, reference);\n                    });\n\n                    // Union sum across all results\n                    return acc + _.union(lcsArr).length;\n                }, 0);\n\n                // Do math.\n                var r = lcsSum / referenceWordCount,\n                    p = lcsSum / candidateWordCount,\n                    beta = p / r; // Note that DUC forces beta to 1.\n\n                var fMeasure = ((1 + beta * beta) * r * p) / (r + beta * beta * p);\n\n                return fMeasure;\n            // Case where multiple references are provided\n            } else if (_.isArray(reference) && reference.length > 1) {\n                return evalJackKnife(candidate, reference, evalLCS);\n            } else {\n                return null;\n            }\n        }\n\n        /**\n         * Returns the ROUGE-S metric for a candidate and a set of references\n         * @param  Array candidate      An array of strings to be compared\n         * @param  Array reference      An array of string arrays to be compared\n         * @param  Boolean jackKnife    Flag for whether jackknifing should be used\n         * @return Number               The calculated ROUGE-S value\n         */\n        var evalSkipBigram = function(candidate, reference) {\n            // Tokenize the candidate input and generate skip bigrams\n            var candidateWords = candidate.match(/\\w+/g),\n                candidateWordCount = candidateWords.length,\n                candidateSkipBigrams = skipBigram(candidateWords),\n                candidateCombs = fact(candidateWordCount) / (2 * fact(candidateWordCount - 2));\n\n            // Case where only one reference is provided\n            if (typeof(reference) === 'string' || (_.isArray(reference) && reference.length === 1)) {\n                // Tokenize the reference input\n                if (typeof(reference) === 'string') {\n                    var referenceWords = reference.match(/\\w+/g);\n                } else {\n                    var referenceWords = reference[0].match(/\\w+/g);\n                }\n\n                // Generate skip bigrams for the reference\n                var referenceWordCount = referenceWords.length,\n                    referenceSkipBigrams = skipBigram(referenceWords),\n                    referenceCombs = fact(referenceWordCount) / (2 * fact(referenceWordCount - 2));\n\n                // Do math\n                var r = candidateSkipBigrams / candidateCombs,\n                    p = referenceSkipBigrams / referenceCombs,\n                    beta = p / r; // Note that DUC forces beta to 1\n\n                var fMeasure = ((1 + beta * beta) * r * p) / (r + beta * beta * p);\n\n                return fMeasure;\n            // Case where multiple references are provided\n            } else if (_.isArray(reference) && reference.length > 1) {\n                return evalJackKnife(candidate, reference, evalSkipBigram);\n            }\n        }\n\n        return {\n            n: evalNGram,\n            l: evalLCS,\n            s: evalSkipBigram,\n            _fact: fact,\n            _lcs: lcs,\n            _extractGram: extractGram,\n            _skipBigram: skipBigram\n        }\n    })(rouge || {});\n\n    // Logic to inject the function into the appropriate environment.\n    // Supports browser loading, Node.JS requires, and AMD.\n    if (typeof(module) === 'object' && module && typeof(module.exports) === 'object') {\n        module.exports = rouge;\n    } else {\n        if (typeof(define) === 'function' && define.amd) {\n            return rouge;\n        } else {\n            window.rouge = rouge;\n        }\n    }\n})(this);\n"],"sourceRoot":"/source/"}